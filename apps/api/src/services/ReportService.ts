import PDFDocument from 'pdfkit';


// Define types manually to avoid import errors
type Graph = any;
type Entity = any;
type Link = any;

export const LicenseTier = {
  OBSERVER: 'OBSERVER',
  ANALYST: 'ANALYST',
  OPERATIVE: 'OPERATIVE',
  DEVELOPER: 'DEVELOPER',
  ENTERPRISE: 'ENTERPRISE',
  CEO: 'CEO'
} as const;

export type LicenseTier = keyof typeof LicenseTier;

export class ReportService {
  
  public async generatePDF(graph: Graph & { entities: Entity[], links: Link[] }, tier: LicenseTier): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      const doc = new PDFDocument({ margin: 50 });
      const buffers: Buffer[] = [];

      doc.on('data', buffers.push.bind(buffers));
      doc.on('end', () => resolve(Buffer.concat(buffers)));
      doc.on('error', reject);

      // --- 1. Header & Title ---
      this.addHeader(doc, tier);
      
      doc.moveDown();
      doc.fontSize(24).font('Helvetica-Bold').text(graph.name, { align: 'center' });
      doc.fontSize(12).font('Helvetica').fillColor('gray').text(graph.description || 'No description provided.', { align: 'center' });
      doc.fillColor('black');
      doc.moveDown(2);

      // --- 2. Executive Summary (Operative+) ---
      if (this.isAdvancedTier(tier)) {
          this.addExecutiveSummary(doc, graph);
          doc.moveDown(2);
      }

      // --- 3. Statistics ---
      doc.fontSize(16).font('Helvetica-Bold').text('Investigation Statistics');
      doc.fontSize(12).font('Helvetica');
      doc.text(`Total Entities: ${graph.entities.length}`);
      doc.text(`Total Links: ${graph.links.length}`);
      doc.text(`Generated: ${new Date().toLocaleString()}`);
      doc.moveDown();

      // --- 4. Entity List ---
      doc.addPage();
      doc.fontSize(16).font('Helvetica-Bold').text('Identified Entities');
      doc.moveDown();

      graph.entities.forEach((entity: any, index: number) => {
          doc.fontSize(12).font('Helvetica-Bold').text(`${index + 1}. ${entity.value} (${entity.type})`);
          
          if (entity.properties) {
              const props = JSON.stringify(entity.properties);
              doc.fontSize(10).font('Helvetica').fillColor('#555555').text(`   Properties: ${props.substring(0, 100)}${props.length > 100 ? '...' : ''}`);
              doc.fillColor('black');
          }
          
          doc.moveDown(0.5);
      });

      // --- Footer ---
      // Note: PDFKit doesn't support total page count easily without buffering beforehand or plugins, 
      // but we can add simple footers.
      
      doc.end();
    });
  }

  private addHeader(doc: PDFKit.PDFDocument, tier: LicenseTier) {
     if (tier === LicenseTier.ENTERPRISE || tier === LicenseTier.CEO) {
         doc.fontSize(10).text('CONFIDENTIAL REPORT', { align: 'right' });
     } else {
         doc.fontSize(10).fillColor('#6366f1').text('Generated by NodeWeaver OSINT', { align: 'right' });
         doc.fillColor('black');
     }
  }

  private addExecutiveSummary(doc: PDFKit.PDFDocument, graph: any) {
      doc.fontSize(16).font('Helvetica-Bold').text('Executive Summary');
      doc.fontSize(12).font('Helvetica').text(
          `This report contains an automated analysis of ${graph.entities.length} entities and their relationships. ` +
          `The investigation graph "${graph.name}" indicates a complex network structure.`
      );
  }

  private isAdvancedTier(tier: LicenseTier) {
      return ([LicenseTier.OPERATIVE, LicenseTier.DEVELOPER, LicenseTier.ENTERPRISE, LicenseTier.CEO] as string[]).includes(tier as string);
  }
}

export const reportService = new ReportService();
